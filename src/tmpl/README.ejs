<%- scriptName = 'resolveIt'%>
<%- Array(scriptName.length+1).join("=") %>

> <%-pkg.description%>

Summary
-------

Given a `searchPath`, and various options, return a resolved path.

Works on the same principle as node's `require.resolve` method does, however, it is far more configurable and does not assume any particular structure. (i.e: you have to give it the structure to search).


Installation
------------

~~~
npm install <%-pkg.name%>
~~~

Usage
-----

~~~
var <%-scriptName%> = require('<%-pkg.name%>'),
    path;

try {
    path = <%-scriptName%>.sync('foo', __dirname, {
        prefix: 'node_modules',
        index: ['index', 'main'],
        extension: ['js', 'node']
    });
}
catch (error) {
    console.log(error);
}

console.log('Found \'foo\' in \'' + path + '\'');
~~~


Public API
----------

### <%-scriptName%>.sync(search, [basedir], [options]) ###

Will return a string (or an array of strings if `options.findAll` is true). Will throw an `Error` if the `search` can not be found (unless `options.silent` is true).

Takes the following arguments:

* `search` a string, the name, or subpath, you want to find
* `basedir` a string, or an array of strings, of the directories you want to start searching from.
* `options` an object with one or more of the following properties:
    * `basedir` a string, or an array of strings, as above. (Replaces the `basedir` argument above.)
    * `prefix` a string, or an array of strings, of sub-directory paths to append to the `basedir` path (i.e: 'node_modules').
    * `index` a string, or an array of strings, possible directory index base-names to try (i.e: 'index', or ['index', 'main']).
    * `extension` a string, or an array of strings, possible file extensions to try (i.e: 'js').
    * `transform` a function. Will receive a string as the first argument, which is the current path being created. Return a string, or an array of strings, to make your own modifications to the paths searched. `false` return values will be filtered out of the search.
    * `findAll` a boolean, set to `true` to return all found paths. Default `false`.
    * `directories` a boolean, set to `true` to allow matches on directories. Default `false`.
    * `silent` a boolean, set to `true` to silently fail (don't throw an exception). Default `false`.

**Note:** `basedir` defaults to the directory of the calling method's file path, or `process.cwd()` if that can not be determined.


Internal API
------------

### <%-scriptName%>.directoryFromStack([startPath]) ###

Using an error stack, try to determine the calling directory.  If passed the optional *startPath* parameter, use that to determine where to start looking in the stack trace.


### <%-scriptName%>.explodePath(path) ###

Takes a `path`, as a string, and explodes it into an array of ascending directories.

~~~js
<%-scriptName%>.explodePath('a/b/c'); // => [ 'a/b/c', 'a/b', 'a', '.' ]
~~~

### <%-scriptName%>.buildPaths(search, [options]) ###

Does the underlying work of building all possible search paths. `search` and `options` are the same as `<%-scriptName%>.sync`'s arguments, with the exception that `options.basedir` is presumed to be defined as a string, or an array of strings. If `options.basedir` is not defined nothing will be returned.

~~~js
<%-scriptName%>.buildPaths('d', { 
    basedir: 'a/b',
    extension: 'js',
    prefix: 'node_modules',
    index: 'index'
});
// would generate the following results:
// a/b/d/e
// a/b/d/e.js
// a/b/d/e/index
// a/b/d/e/index.js
// a/b/d/node_modules/e
// a/b/d/node_modules/e.js
// a/b/d/node_modules/e/index
// a/b/d/node_modules/e/index.js
// a/d/e
// a/d/e.js
// a/d/e/index
// a/d/e/index.js
// a/d/node_modules/e
// a/d/node_modules/e.js
// a/d/node_modules/e/index
// a/d/node_modules/e/index.js
// d/e
// d/e.js
// d/e/index
// d/e/index.js
// d/node_modules/e
// d/node_modules/e.js
// d/node_modules/e/index
// d/node_modules/e/index.js
~~~


Report an Issue
---------------

* [Bugs](<%-pkg.bugs.url%>)
* Contact the author: <jhamlet@hamletink.com>


License
-------

<%-license.split("\n").map(function (line) { return "> " + line; }).join("\n")%>
