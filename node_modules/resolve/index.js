
var Path    = require('path'),
    FS      = require('fs'),
    isArray = Array.isArray;

//---------------------------------------------------------------------------
// Array extensions for functional programming
//---------------------------------------------------------------------------
Array.prototype.flatten = function () {
    return this.reduce(function (acc, cur) {
        return acc.concat(cur);
    }, []);
};

Array.prototype.mapMany = function () {
    return this.map.apply(this, arguments).flatten();
};
//---------------------------------------------------------------------------
// Utilities
//---------------------------------------------------------------------------
function makeArray (value) {
    return isArray(value) ?
        value :
        typeof value !== 'undefined' ? [value] : [];
}
/**
 * Explode a file path into all possible paths, even no path
 * 
 * i.e: a/b/c => a/b/c, a/b, a, ''
 * 
 * @param {String} path
 * @returns {Array[String]}
 * @protected
 */
function explodePath (path) {
    var paths = path.split(Path.sep).reduceRight(function (acc, cur, idx, list) {
        acc.push(Path.join.apply(Path, list.slice(0, idx+1)));
        return acc;
    }, []);
    paths.push('');
    return paths;
}
/**
 * Generate the possible path resolutions that we can find our file.
 * 
 *  1. Explode the basedir into all possible paths a/b/c => a/b/c, a/b, a, ''
 *  2. For each prefix, duplicate and append
 *  3. Do the same for indices
 *  4. And finally do the same with the extensions
 * 
 * i.e: buildPaths('d/e', 'a/b/c', 'js', 'node_modules', 'index') would
 * result in the following paths:
 *  
 *  a/b/c/d/e
 *  a/b/c/d/e.js
 *  a/b/c/d/e/index
 *  a/b/c/d/e/index.js
 *  a/b/c/d/node_modules/e
 *  a/b/c/d/node_modules/e.js
 *  a/b/c/d/node_modules/e/index
 *  a/b/c/d/node_modules/e/index.js
 *  a/b/d/e
 *  a/b/d/e.js
 *  a/b/d/e/index
 *  a/b/d/e/index.js
 *  a/b/d/node_modules/e
 *  a/b/d/node_modules/e.js
 *  a/b/d/node_modules/e/index
 *  a/b/d/node_modules/e/index.js
 *  a/d/e
 *  a/d/e.js
 *  a/d/e/index
 *  a/d/e/index.js
 *  a/d/node_modules/e
 *  a/d/node_modules/e.js
 *  a/d/node_modules/e/index
 *  a/d/node_modules/e/index.js
 *  d/e
 *  d/e.js
 *  d/e/index
 *  d/e/index.js
 *  d/node_modules/e
 *  d/node_modules/e.js
 *  d/node_modules/e/index
 *  d/node_modules/e/index.js
 * 
 * @param {String} subpath the subpath we are looking for
 * @param {String|Array[String]} basedirs the starting directories climb
 * @param {String|Array[String]} exts extension types to try
 * @param {String|Array[String]} prefixes possible 'module' directories
 * @param {String|Array[String]} indices 'index' basenames to try
 * @returns {Array[String]}
 * @protected
 */
function buildPaths (subpath, basedirs, exts, prefixes, indices) {
    return makeArray(basedirs).mapMany(function (dir) {
        var isAbs = dir.indexOf(Path.sep) === 0;
        return explodePath(dir).map(function (path) {
            return (isAbs ? Path.sep : '') + path;
        });
    }).mapMany(function (dir) {
        return prefixes ?
            [dir].concat(makeArray(prefixes).map(function (prefix) {
                return Path.join(dir, prefix);
            })) :
            dir;
    }).map(function (dir) {
        return Path.join(dir, subpath);
    }).mapMany(function (path) {
        return indices ?
            [path].concat(makeArray(indices).map(function (index) {
                return Path.join(path, index);
            })) :
            path;
    }).mapMany(function (path) {
        return exts ?
            [path].concat(makeArray(exts).map(function (ext) {
                return path + '.' + ext;
            })) :
            path;
    });
}
//---------------------------------------------------------------------------
// Main
//---------------------------------------------------------------------------
function resolveSync (path, opts) {
    var found, foundpath, dirIsAbs;
    
    opts = opts || {};
    
    if (!opts.basedir) {
        opts.basedir = process.cwd();
    }
    
    if (path.indexOf(Path.sep) === 0) {
        // If we're given a absolute path then test that
        if (FS.existsSync(path)) {
            foundpath = path;
            found = true;
        }
    }
    else {
        found = buildPaths(
            path,
            opts.basedir,
            opts.prefix,
            opts.index,
            opts.extension
        ).some(function (path) {
            if (FS.existsSync(path)) {
                foundpath = foundpath;
                return true;
            }
            return false;
        });
    }
    
    if (!found) {
        throw new Error('Can not resolve \'' + path + '\'');
    }
    
    return foundpath;
}

/**
 * @param {String} path the path you are looking for
 * @param {Object} [opts] options object
 *      @property {String|Array[String]} [opts.basedir = process.cwd()]
 *      @property {String|Array[String]} [opts.extension]
 *      @property {String|Array[String]} [opts.prefix]
 *      @property {String|Array[String]} [opts.index]
 * @param {Function} callback
 *      @param {Error}
 *      @param {String} resolved path
 */
function resolve (path, opts, callback) {
    if (arguments.length < 3 && typeof opts === 'function') {
        callback = opts;
        opts = null;
    }
    
    process.nextTick(function () {
        var respath;
        
        try {
            respath = resolveSync(path, opts);
        }
        catch (err) {
            callback(err);
        }
        
        callback(null, respath);
    });
}

Object.defineProperties(resolve, {
    explodePath: { value: explodePath },
    buildPaths: { value: buildPaths }
});

resolve.sync = resolveSync;
module.exports = resolve;