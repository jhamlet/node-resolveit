
var Path    = require('path'),
    FS      = require('fs'),
    isArray = Array.isArray,
    slice   = Array.prototype.slice,
    STACK_LINE_REGEX = /^\s*at\s+([^\s]+)\s+\(([^:]+):(\d+):(\d+)\)$/;

//---------------------------------------------------------------------------
// Array extensions for functional programming
//---------------------------------------------------------------------------
/*globals flatten, mapMany*/
function f (list) {
    // We add to our array instances so we do not pollute the Array prototype
    return Object.defineProperties(list, {
        flatten: { value: flatten },
        mapMany: { value: mapMany }
    });
}

function flatten () {
    return f(this.reduce(function (acc, cur) {
        return acc.concat(cur);
    }, []));
}

function mapMany () {
    return f(this.map.apply(this, arguments)).flatten();
}
//---------------------------------------------------------------------------
// Utilities
//---------------------------------------------------------------------------
function makeArray (value) {
    return f(isArray(value) ?
        value :
        typeof value !== 'undefined' ? [value] : []);
}

function directoryFromStack (startPath) {
    var error = new Error(),
        stack = error.stack.split('\n'),
        selfPath = __filename,
        otherPath;
    
    // console.log(error.stack);
    
    stack.some(function (line) {
        var isSelf = ~line.indexOf(selfPath),
            isStart = startPath && ~line.indexOf(startPath),
            match;
            
        if (!isSelf && !isStart && (match = STACK_LINE_REGEX.exec(line))) {
            otherPath = match[2];
            return true;
        }
        
        return false;
    });
    
    return Path.dirname(otherPath);
}

function explodePath (path) {
    var paths;
    
    paths = path.split(Path.sep).reduceRight(function (acc, cur, idx, list) {
        acc.push(Path.join.apply(Path, list.slice(0, idx+1)));
        return acc;
    }, []);
    
    paths.push('.');
    
    return f(paths);
}

function buildPaths (search, opts) {
    // absolute search path?
    if (search.indexOf(Path.sep) === 0) {
        return f([search]);
    }
    
    return makeArray(opts.basedir).mapMany(function (dir) {
        // Split up our base directories to search and construct a breadcrumb
        // trail of paths to follow
        var isAbs = dir.indexOf(Path.sep) === 0;
        return explodePath(dir).map(function (path) {
            return (isAbs ? Path.sep : '') + path;
        });
    }).mapMany(function (dir) {
        // return the path, and a for each prefix a path with the prefix appended
        return !opts.prefix ? dir :
            [dir].concat(makeArray(opts.prefix).map(function (prefix) {
                return Path.join(dir, prefix);
            }));
    }).mapMany(function (dir) {
        // add the search path to our pats
        return Path.join(dir, search);
    }).mapMany(function (path) {
        // return the path, and for each index a path with the index appended
        return !opts.index ? path :
            [path].concat(makeArray(opts.index).map(function (index) {
                return Path.join(path, index);
            }));
    }).mapMany(function (path) {
        // again, return the path, and for each extension a path with the
        // extension appended
        return !opts.extension ? path :
            [path].concat(makeArray(opts.extension).map(function (ext) {
                return path + '.' + ext;
            }));
    }).mapMany(function (path) {
        return !opts.transform ? path : opts.transform(path);
    }).
    filter(Boolean).
    map(function (path) {
        return Path.normalize(path);
    });
}
//---------------------------------------------------------------------------
// Main
//---------------------------------------------------------------------------
module.exports = Object.defineProperties({
    /**
     * @param {String} search the path you are looking for
     * @param {String|Array[String]} [basedir = process.cwd()] base
     *      directories to search,
     * @param {Object} [opts] an options object
     *      @property {String|Array[String]} [opts.basedir]
     *      @property {String|Array[String]} [opts.extension]
     *      @property {String|Array[String]} [opts.prefix]
     *      @property {String|Array[String]} [opts.index]
     *      @property {Function} [opts.transform]
     *          @param {String} the path to transform
     *          @returns {String|Array[String]} these will be appended
     *              to the search
     *      @property {Boolean} [opts.findAll] return all matching results?
     *      @property {Boolean} [opts.directories] match on directories?
     *      @property {Boolean} [opts.silent] don't throw an exception when
     *          search can't be resolved
     * @returns {String}
     * @throws {Error} if the path can not be resolved
     */
    sync: function (search, basedir, opts) {
        var findAll, allowDirs, paths, foundpath;

        if (typeof basedir === 'object' && !isArray(basedir)) {
            opts = basedir;
            basedir = null;
        }
        
        opts = opts || {};
        
        if (!opts.basedir) {
            opts.basedir = basedir || directoryFromStack() || process.cwd();
        }

        findAll = opts.findAll;
        allowDirs = opts.directories;
        
        paths = buildPaths(search, opts)[findAll ? 'filter' : 'some'](
            function (filepath) {
                var path    = filepath.toString(),
                    exists  = FS.existsSync(path),
                    stat    = exists && FS.statSync(path),
                    isFile  = stat && stat.isFile(),
                    isDir   = stat && stat.isDirectory(),
                    matches = stat && (allowDirs ? isDir : isFile) || isFile;
                    
                if (exists && matches) {
                    foundpath = path;
                    return true;
                }
                
                return false;
            }
        );
        
        if (paths === true || paths.length) {
            return findAll ? paths : foundpath;
        }

        if (!opts.silent) {
            throw new Error('Can not resolve \'' + search + '\'');
        }
    }
}, {
    /**
     * Explode a file path into all possible paths
     * 
     * i.e: 'a/b/c' => 'a/b/c', 'a/b', a, ''
     * 
     * @param {String} path
     * @returns {Array[String]}
     * @protected
     */
    explodePath: { value: explodePath },
    /**
     * Generate the possible path resolutions where we find search path.
     * 
     *  1. Explode the basedir into all possible paths in ascending order
     *  2. For each prefix, return the path and one with the prefix appended
     *  3. Add the search path to each of those
     *  4. For each index, return the path and one with the prefix appended
     *  5. And finally do the same with the extensions
     *  6. If supplied a transform function, pass it the path and use
     *      what it returns (string, or array of strings)
     *  7. Filter out any non-truthy values
     *  8. Normalize the path
     * 
     * i.e:
     * 
     *  buildPaths('d', { 
     *      basedir: 'a/b',
     *      extension: 'js',
     *      prefix: 'node_modules',
     *      index: 'index'
     *  }) // would result in the following paths:
     *  
     *  a/b/d/e
     *  a/b/d/e.js
     *  a/b/d/e/index
     *  a/b/d/e/index.js
     *  a/b/d/node_modules/e
     *  a/b/d/node_modules/e.js
     *  a/b/d/node_modules/e/index
     *  a/b/d/node_modules/e/index.js
     *  a/d/e
     *  a/d/e.js
     *  a/d/e/index
     *  a/d/e/index.js
     *  a/d/node_modules/e
     *  a/d/node_modules/e.js
     *  a/d/node_modules/e/index
     *  a/d/node_modules/e/index.js
     *  d/e
     *  d/e.js
     *  d/e/index
     *  d/e/index.js
     *  d/node_modules/e
     *  d/node_modules/e.js
     *  d/node_modules/e/index
     *  d/node_modules/e/index.js
     * 
     * @param {String} path the subpath we are looking for
     * @param {Object} opts
     *      @property {String|Array[String]} opts.basedir
     *      @property {String|Array[String]} [opts.extension]
     *      @property {String|Array[String]} [opts.prefix]
     *      @property {String|Array[String]} [opts.index]
     *      @property {Function} [opts.transform]
     *          @param {String}
     *          @returns {String-like|Array[String-like]}
     *      @property {Boolean} [opts.findAll]
     * @returns {Array[String]}
     * @protected
     */
    buildPaths: { value: buildPaths },
    /**
     * Using an error stack, try to determine the calling directory.  If
     * passed the optional *filepath* parameter, use that to determine where
     * to start looking in the stack trace.
     * 
     * @method directoryFromStack
     * @param {String} filepath optional
     * @returns {String}
     */
    directoryFromStack: { value: directoryFromStack }
});
